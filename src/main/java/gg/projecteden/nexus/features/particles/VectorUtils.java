package gg.projecteden.nexus.features.particles;

import org.bukkit.Location;
import org.bukkit.util.Vector;

public class VectorUtils {

	private VectorUtils() {
	}

	public static final Vector rotateAroundAxisX(Vector v, double angle) {
		double y, z, cos, sin;
		cos = Math.cos(angle);
		sin = Math.sin(angle);
		y = v.getY() * cos - v.getZ() * sin;
		z = v.getY() * sin + v.getZ() * cos;
		return v.setY(y).setZ(z);
	}

	public static final Vector rotateAroundAxisY(Vector v, double angle) {
		double x, z, cos, sin;
		cos = Math.cos(angle);
		sin = Math.sin(angle);
		x = v.getX() * cos + v.getZ() * sin;
		z = v.getX() * -sin + v.getZ() * cos;
		return v.setX(x).setZ(z);
	}

	public static final Vector rotateAroundAxisZ(Vector v, double angle) {
		double x, y, cos, sin;
		cos = Math.cos(angle);
		sin = Math.sin(angle);
		x = v.getX() * cos - v.getY() * sin;
		y = v.getX() * sin + v.getY() * cos;
		return v.setX(x).setY(y);
	}

	public static final Vector rotateVector(Vector v, double angleX, double angleY, double angleZ) {
		// double x = v.getX(), y = v.getY(), z = v.getZ();
		// double cosX = Math.cos(angleX), sinX = Math.sin(angleX), cosY =
		// Math.cos(angleY), sinY = Math.sin(angleY), cosZ = Math.cos(angleZ),
		// sinZ = Math.sin(angleZ);
		// double nx, ny, nz;
		// nx = (x * cosY + z * sinY) * (x * cosZ - y * sinZ);
		// ny = (y * cosX - z * sinX) * (x * sinZ + y * cosZ);
		// nz = (y * sinX + z * cosX) * (-x * sinY + z * cosY);
		// return v.setX(nx).setY(ny).setZ(nz);
		// Having some strange behavior up there.. Have to look in it later. TODO
		rotateAroundAxisX(v, angleX);
		rotateAroundAxisY(v, angleY);
		rotateAroundAxisZ(v, angleZ);
		return v;
	}

	/**
	 * Rotate a vector about a location using that location's direction
	 *
	 * @param v
	 * @param location
	 * @return
	 */
	public static final Vector rotateVector(Vector v, Location location) {
		return rotateVector(v, location.getYaw(), location.getPitch());
	}

	/**
	 * This handles non-unit vectors, with yaw and pitch instead of X,Y,Z angles.
	 * <p>
	 * Thanks to SexyToad!
	 *
	 * @param v
	 * @param yawDegrees
	 * @param pitchDegrees
	 * @return
	 */
	public static final Vector rotateVector(Vector v, float yawDegrees, float pitchDegrees) {
		double yaw = Math.toRadians(-1 * (yawDegrees + 90));
		double pitch = Math.toRadians(-pitchDegrees);

		double cosYaw = Math.cos(yaw);
		double cosPitch = Math.cos(pitch);
		double sinYaw = Math.sin(yaw);
		double sinPitch = Math.sin(pitch);

		double initialX, initialY, initialZ;
		double x, y, z;

		// Z_Axis rotation (Pitch)
		initialX = v.getX();
		initialY = v.getY();
		x = initialX * cosPitch - initialY * sinPitch;
		y = initialX * sinPitch + initialY * cosPitch;

		// Y_Axis rotation (Yaw)
		initialZ = v.getZ();
		initialX = x;
		z = initialZ * cosYaw - initialX * sinYaw;
		x = initialZ * sinYaw + initialX * cosYaw;

		return new Vector(x, y, z);
	}

	public static final double angleToXAxis(Vector vector) {
		return Math.atan2(vector.getX(), vector.getY());
	}

	public static Vector getBackVector(Location location) {
		float newZ = (float) (location.getZ() + 1.0D * Math.sin(Math.toRadians(location.getYaw() + 90.0F)));
		float newX = (float) (location.getX() + 1.0D * Math.cos(Math.toRadians(location.getYaw() + 90.0F)));
		return new Vector((double) newX - location.getX(), 0.0D, (double) newZ - location.getZ());
	}

	public static Vector getRandomDirection() {
		Vector direction = new Vector();
		direction.setX(Math.random() * 2.0 - 1.0);
		direction.setY(Math.random());
		direction.setZ(Math.random() * 2.0 - 1.0);
		return direction.normalize();
	}
}
